<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script src="https://use.typekit.net/xbr6agj.js"></script><script>try{Typekit.load({ async: true });}catch(e){}</script><script>window['_fs_debug'] = false;
window['_fs_host'] = 'fullstory.com';
window['_fs_org'] = '6WVGW';
window['_fs_namespace'] = 'FS';
(function(m,n,e,t,l,o,g,y){
if (e in m) {if(m.console && m.console.log) { m.console.log('FullStory namespace conflict. Please set window["_fs_namespace"].');} return;}
g=m[e]=function(a,b){g.q?g.q.push([a,b]):g._api(a,b);};g.q=[];
o=n.createElement(t);o.async=1;o.src='https://'+_fs_host+'/s/fs.js';
y=n.getElementsByTagName(t)[0];y.parentNode.insertBefore(o,y);
g.identify=function(i,v){g(l,{uid:i});if(v)g(l,v)};g.setUserVars=function(v){g(l,v)};
g.identifyAccount=function(i,v){o='account';v=v||{};v.acctId=i;g(o,v)};
g.clearUserCookie=function(c,d,i){if(!c || document.cookie.match('fs_uid=[`;`]*`[`;`]*`[`;`]*`')){
d=n.domain;while(1){n.cookie='fs_uid=;domain='+d+
';path=/;expires='+new Date(0).toUTCString();i=d.indexOf('.');if(i<0)break;d=d.slice(i+1)}}};
})(window,document,window['_fs_namespace'],'script','user');
</script><title> Getting Started With Nginx Configuration · Raj Abishek</title><meta name="description" content="Getting Started With Nginx Configuration - Raj Abishek"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/logo.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">Blog</a></li><li class="nav-list-item"><a href="https://dribbble.com/rajabishek" target="_blank" class="nav-list-link">Dribbble</a></li><li class="nav-list-item"><a href="https://in.linkedin.com/in/rajabishek" target="_blank" class="nav-list-link">LinkedIn</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">Rss</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Getting Started With Nginx Configuration</h1><div class="post-info">May 17, 2016</div><div class="post-content"><h2 id="Lets-dive-a-little-deeper"><a href="#Lets-dive-a-little-deeper" class="headerlink" title="Lets dive a little deeper"></a>Lets dive a little deeper</h2><p>When it comes to configuring servers and provisioning them it really becomes a pain in the ass if we don’t understand what’s happening under the hood. Sometimes a configuration would work and sometimes it wouldn’t. The reason for all these problems boils down to poor understanding of the directives that are used for configuration and not taking effort to read the documentation and researching on some of the best practices that need to be used. So lets dive a little deeper and experiment with Nginx configuration.</p>
<a id="more"></a>
<h2 id="TRY-FILES"><a href="#TRY-FILES" class="headerlink" title="TRY_FILES"></a>TRY_FILES</h2><p>A very common try_files line which can be applied on your condition is<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">	try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /<span class="built_in">test</span>/index.html;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>You probably understand the first part, location / matches all locations, unless it’s matched by a more specific location, like location    /test for example. The second part ( the try_files ) means when you receive a URI that’s matched by this block try $uri first, for example <a href="http://example.com/images/image.jpg" target="_blank" rel="external">http://example.com/images/image.jpg</a> nginx will try to check if there’s a file inside /images called image.jpg if found it will serve it first.</p>
<p>Second condition is $uri/ which means if you didn’t find the first condition $uri try the URI as a directory, for example <a href="http://example.com/images/" target="_blank" rel="external">http://example.com/images/</a> , ngixn will first check if a file called images exists then it wont find it, then goes to second check $uri/ and see if there’s a directory called images exists then it will try serving it. If there is no images directory it will retort to the third fallback option.</p>
<p>If there exists a directory called images and there is a index directive defined the nginx will try to check if the index exists inside this folder. For example if index is defined as index    index.html    index.htm then first nginx will try to serve the index.html file inside the images folder. If not present then it will try to serve the index.htm file inside the images folder. If none of the files listed in index directive is found or if the index directive was not at all present, then nginx will try to do a directory listing for the images folder. Now by default auto index is turned off in nginx, meaning directory listen must not be allowed. Therefore if we don’t set auto index as on explicitly using autoindex on you’ll probably get a 403 forbidden error, because directory listing is forbidden by default. It is a good practise to leave auto index as off because it can expose contents present under the document root.</p>
<p>If there is no images directory then the third condition /test/index.html is considered a fall back option, (you need to use at least 2 options, one and a fall back), you can use as much as you can (never read of a constriction before), nginx will look for the file index.html inside the folder test and serve it if it exists. If the third condition fails too, then nginx will serve the 404 error page.</p>
<p>So the basic ﬂow is as follows </p>
<ul>
<li>Tries to server the static ﬁle directly</li>
<li>Checks if there is a folder in the given name of uri </li>
<li>If folder is present and index directive is there nginx tries to serve the index ﬁles in the folder </li>
<li>If no folder exists or there are no index ﬁles in the folder then tries to do a directory listing</li>
<li>If there is no auto index directive we get a 403 forbidden error</li>
<li>If auto index index is turned on explicitly using autoindex on then nginx does a directory listing. </li>
</ul>
<p>Also there’s something called named locations, like this<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location @error	&#123; &#125;</div></pre></td></tr></table></figure></p>
<p>You can call it with try_files like this<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ @error;</div></pre></td></tr></table></figure></p>
<p>TIP: If you only have 1 condition you want to serve, like for example inside folder images you only want to either serve the image or go to 404 error, you can write a line like this<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location /images &#123; try_files <span class="variable">$uri</span> =404; &#125;</div></pre></td></tr></table></figure></p>
<p>which means either serve the ﬁle or serve a 404 error, you can’t use only $uri by it self without =404 because you need to have a fallback option. You can also choose which ever error code you want, like for example:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location /images &#123; try_files <span class="variable">$uri</span> =403; &#125;</div></pre></td></tr></table></figure></p>
<p>This will show a forbidden error if the image doesn’t exist, or if you use 500 it will show server error, etc ..</p>
<h2 id="SERVER-BLOCK"><a href="#SERVER-BLOCK" class="headerlink" title="SERVER_BLOCK"></a>SERVER_BLOCK</h2><p>Consider the following ﬁle /etc/nginx/sites-available/default Nginx can have diﬀerent server blocks. Each server block is wrapped within server { }<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server	&#123;</div><div class="line">... &#125;</div><div class="line"></div><div class="line">server	&#123;</div><div class="line">... &#125;</div><div class="line"></div><div class="line">server	&#123;</div><div class="line">... &#125;</div></pre></td></tr></table></figure></p>
<p>The above file for example contains 3 server blocks. Different server blocks is what allows nginx to server different sites from the same server. When a HTTP request comes to nginx it first identifies the host and the port from the request headers. One of the headers in the request usually contains the host information. If a header is  ‘Host: example.com:8080’ then it means that the value of the Host header is example.com:8080. Therefore the host is example.com and the port is 8080. Once the host and port is identified by nginx it finds a matching  server block for the configurations. If there is not port then the implicit port 80 is used.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">server	&#123;	</div><div class="line">	listen	80;				</div><div class="line">	listen	[::]:80;				</div><div class="line">	server_name	example.com	</div><div class="line">	www.example.com;				</div><div class="line">	... &#125; </div><div class="line"></div><div class="line">server	&#123;</div><div class="line">	listen	80	default_server;</div><div class="line">	listen	[::]:80	default_server;</div><div class="line">	server_name	example.net;				</div><div class="line">... &#125;</div><div class="line"></div><div class="line">server	&#123;</div><div class="line">	listen	80;				</div><div class="line">	listen	[::]:80;</div><div class="line">	server_name	example.app;</div><div class="line">... &#125;</div><div class="line"></div><div class="line">server	&#123;				</div><div class="line">	listen	80;</div><div class="line">	listen	[::]:80;</div><div class="line">	server_name	<span class="string">""</span>;</div><div class="line">	<span class="built_in">return</span>	444;</div><div class="line">... &#125;</div></pre></td></tr></table></figure></p>
<p>Now with the above configuration a request with Host header as ‘Host: example.com’. The host is example.com and port is 80. Now to serve this request the first server block is used since that is the matching one. Now there can be possibilities where there is no matching server block, for example if the host header is ‘Host: example.org’, in these cases the server block having the default_server directive is used to process the request. So here in the above case the second server block would be used to serve the request. </p>
<p>Now if there is no host header present at all in the request the matching server name is “”. In the above case the 4th server block is used as it has the the server_name as “”. If the fourth server_block was not defined above then in that case the server block having the default_server directive would be used.</p>
<p>Essentially whenever for a given host the matching server block is not found the server block having the default_server directive is used. And as you can see above a server block can have multiple server names, the first server block would be used to serve the request from both example.com and www.example.com on port 80. When we type <a href="http://example.com" target="_blank" rel="external">http://example.com</a> in our browser we are actually making a get request to the server with request header as ‘Host: example.com’ i.e host is example.com and port is 80.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server	&#123;			</div><div class="line">	listen	80	default_server;</div><div class="line">	listen	[::]:80	default_server;</div><div class="line">	root	/var/www/html;</div><div class="line">	<span class="comment"># Add index.php	to the list	if you are using PHP				</span></div><div class="line">	index index.html index.htm index.nginx-debian.html;</div><div class="line">	server_name	192.168.33.11;</div><div class="line">	location / &#123;</div><div class="line">	try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /cool/bro/file.txt;</div><div class="line">	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>If there is no default_server set on any server block then the first server block is used a the default server by nginx. Here there is only one server block and thus it automatically becomes the default one. But it is a good practice to state the default server block explicitly and thus we have use the default_server to indicate that this server block must be used in case there is no matching host found or in case there is no host header in the incoming request.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/Arrays-in-Swift/" class="prev">PREV</a><a href="/2016/Concurrency-in-Swift/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://rajabishek.com">Raj Abishek</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-93252193-1",'auto');ga('send','pageview');</script></body></html>