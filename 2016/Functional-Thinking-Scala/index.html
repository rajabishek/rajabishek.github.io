<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script src="https://use.typekit.net/xbr6agj.js"></script><script>try{Typekit.load({ async: true });}catch(e){}</script><script>window['_fs_debug'] = false;
window['_fs_host'] = 'fullstory.com';
window['_fs_org'] = '6WVGW';
window['_fs_namespace'] = 'FS';
(function(m,n,e,t,l,o,g,y){
if (e in m) {if(m.console && m.console.log) { m.console.log('FullStory namespace conflict. Please set window["_fs_namespace"].');} return;}
g=m[e]=function(a,b){g.q?g.q.push([a,b]):g._api(a,b);};g.q=[];
o=n.createElement(t);o.async=1;o.src='https://'+_fs_host+'/s/fs.js';
y=n.getElementsByTagName(t)[0];y.parentNode.insertBefore(o,y);
g.identify=function(i,v){g(l,{uid:i});if(v)g(l,v)};g.setUserVars=function(v){g(l,v)};
g.identifyAccount=function(i,v){o='account';v=v||{};v.acctId=i;g(o,v)};
g.clearUserCookie=function(c,d,i){if(!c || document.cookie.match('fs_uid=[`;`]*`[`;`]*`[`;`]*`')){
d=n.domain;while(1){n.cookie='fs_uid=;domain='+d+
';path=/;expires='+new Date(0).toUTCString();i=d.indexOf('.');if(i<0)break;d=d.slice(i+1)}}};
})(window,document,window['_fs_namespace'],'script','user');
</script><title> Functional Thinking - Scala · Raj Abishek</title><meta name="description" content="Functional Thinking - Scala - Raj Abishek"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/logo.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">Blog</a></li><li class="nav-list-item"><a href="https://dribbble.com/rajabishek" target="_blank" class="nav-list-link">Dribbble</a></li><li class="nav-list-item"><a href="https://in.linkedin.com/in/rajabishek" target="_blank" class="nav-list-link">LinkedIn</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">Rss</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Functional Thinking - Scala</h1><div class="post-info">Oct 17, 2016</div><div class="post-content"><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Scala stands for “Scalable Language”. Its a language that is meant to grow with its users. It can be used for building large systems and frameworks of reusable components. It runs on the standard Java platform and is interoperable with all Java libraries. It is statically typed with a blend of object-oriented and functional programming.</p>
<a id="more"></a>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>To get the official Scala installation, you can visit the official <a href="http://www.scala-lang.org/downloads" target="_blank" rel="external">downloads</a> page and follow the directions for your platform. You can also use a Scala plug-in for Eclipse, IntelliJ, or NetBeans. To check if Scala is installed correctly you can run <code>scala -version</code> on the command line to check the version installed.</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>All of Java’s primitive types have corresponding classes in the <code>scala</code> package. For instance <code>scala.Boolean</code> corresponds to Java’s boolean. <code>scala.Float</code> corresponds to Java’s float. When we compile the Scala code to Java bytecodes, the Scala compiler will use Java’s primitive types where possible to give you the performance benefits of the primitive types.</p>
<p>Scala has two kinds of variables, vals and vars. A val is like a constant which once initialized can never be reassigned. A var, by contrast, is a normal variable that can be reassigned throughout its lifetime.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> message = <span class="string">"Helloworld from Raj Abishek"</span></div></pre></td></tr></table></figure></p>
<p>The type of message is <code>java.lang.String</code>, because Scala strings are implemented by Java’s String class. But if you notice above we never mentioned the type while creating the message val. This is called as type inference. The Scala interpreter(or compiler) can infer types based on the initial value that we assign while declaring the variable. In fact it is often best to let the compiler do so rather than specifying a type explicitly using type annotation.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> name: java.lang.<span class="type">String</span> = <span class="string">"Raj Abishek"</span></div><div class="line"><span class="keyword">val</span> friend: <span class="type">String</span> = <span class="string">"Sailesh Dev"</span> <span class="comment">//using the simple name for type annotation</span></div></pre></td></tr></table></figure></p>
<p>As you see above here we have used type annotations to explicitly explicitly the type of name. The <code>java.lang</code> types are visible with their simple names in Scala. The simple name of <code>java.lang.String</code> is <code>String</code>. As I had mentioned earlier what we can’t do with message or name or friend, given that it is a val, not a var, is reassign it.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greeting = <span class="string">"Good morning!"</span></div><div class="line">greeting = <span class="string">"Good evening!"</span> <span class="comment">//Perfectly valid since greeting is a var</span></div></pre></td></tr></table></figure></p>
<p>We start function definitions with the <code>def</code> keyword. The function’s name as shown below is minimum and it is followed by a comma separated list of parameters in parentheses with type annotations for every parameter. After the close parenthesis of minimum’s parameter list we type annotate the result type of the function. In Scala the type of value returned from a function is called as result type(In Java we call it return type). Following the function’s result type is an equals sign and pair of curly braces which contains the function body.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</div><div class="line">  <span class="keyword">if</span> (x &lt; y)</div><div class="line">    x</div><div class="line">  <span class="keyword">else</span></div><div class="line">    y</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Scala’s if expression can result in a value, just like Java’s ternary operator. The <code>if(x &lt; y) x else y</code> expression in Scala behaves similarly to <code>(x &lt; y) ? x : y</code> in Java. The result type of the function is not always required to be mentioned. If we leave the result type off and the compiler can infer it. But in some cases like recursive functions the Scala compiler will require you to explicitly specify the result type of a function. Also in Scala if the function consists of just one statement, you can leave off the curly braces.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = <span class="keyword">if</span> (x &lt; y) x <span class="keyword">else</span> y</div></pre></td></tr></table></figure></p>
<p>As you can see above the result type of the function is omitted and the curly brace is removed since function body just has a single if statement.<br>Nevertheless, it is often a good idea to indicate function result types explicitly, even when the compiler doesn’t require it. Such type annotations can make the code easier to read. Another developer working on the project need not study the function body to figure out the inferred result type.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>() = println(<span class="string">"Helloworld from Raj Abishek"</span>)</div></pre></td></tr></table></figure></p>
<p>The above is an example of function declaration the accepts no parameters and returns nothing. The result type of greet function is <code>Unit</code>. Scala’s <code>Unit</code> type is similar to Java’s void type. Every <code>void</code> returning method in Java is mapped to a <code>Unit</code> returning method in Scala.<br>As we will see later the above <code>greet</code> function is not pure. A pure function is a function where the result value is only determined by its input values, without observable side effects. Its takes input through parameters, processes the input and returns a value. As we will see later a pure function always gives the same output for a given input, it produces no side effects and does not rely on any external state. In simpler terms a function is impure is if it makes sense to call it without using its return value. Methods with the result type of <code>Unit</code>, therefore, are only executed for their side effects. In the case of <code>greet</code> function, the side effect is a friendly greeting printed to the standard output.</p>
<p>While executing the Scala file we can pass command line arguments which is in the <code>args</code> array. Arrays are zero based and can be positionally indexed with parentheses. So the ith element in a Scala array named data is <code>data(i-1)</code>, not <code>data[0]</code>, as in Java.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">println(<span class="string">"Hello world from "</span> + args(<span class="number">0</span>)) <span class="comment">//get the command line argument</span></div></pre></td></tr></table></figure></p>
<p>In all of the above shown sample code we never wrapped the code within a main method of a class like how we do it in Java. Thats because even though Scala is designed to help developers build very large-scale systems, it also scales down nicely to scripting. A script is just a sequence of statements in a file that will be executed sequentially.</p>
<p>Just like comments behave the same way in Scala. The Scala compiler will ignore characters between <code>//</code> and the next end of line and any characters between <code>/*</code> and <code>*/</code>.</p>
<p>To loop through the elements of the array using a while loop we do the following.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Non idiomatic code</span></div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> (i &lt; args.length) &#123;</div><div class="line">  println(args(i))</div><div class="line">  i += <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>You should understand here that although while loops are explained here, they do not demonstrate the best Scala style. Later we shall see better approaches that avoid iterating through arrays with indexes. The above code that loops through the array through positional indexing via a while loop is not seen as the natural way of lopping through an array in Scala. Note here that Java’s ++i and i++ don’t work in Scala, to increment in Scala we either do i = i + 1 or i += 1. There is also a <code>print</code> function in Scala that prints out a string without a line break. So to print out the command line arguments on the same line we can do the following.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">  <span class="keyword">while</span> (i &lt; args.length) &#123;</div><div class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>)</div><div class="line">    print(<span class="string">" "</span>)</div><div class="line">    print(args(i))</div><div class="line">    i += <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">println()</div></pre></td></tr></table></figure></p>
<p>Like Java, in Scala you must put the boolean expression for a while or an if in parentheses.(You can’t do things like if i &lt; 10 as you can in a languages such as Python, Ruby). Another similarity to Java is that if a block has only one statement, you can optionally leave off the curly braces. Also in Scala adding semicolons at the end of a line is optional(Scala won’t complain if you prefer adding semicolons). But semicolons are required if you want to write multiple statements on a single line.</p>
<p>When we wrote the while loops above we were programming in an imperative style. In languages such a Java, C, C++ we give one imperative command at a time, iterate with loops, and often mutate state shared between different functions. One of the main characteristics of a functional language is that functions are first class constructs. Although Scala allows us to program in imperative style as we saw above(positional indexing with while), we will find ourselves using functional style more as we dive deeper into Scala.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">args.foreach(arg =&gt; println(arg))</div></pre></td></tr></table></figure></p>
<p>The above code is how we would achieve the same result functionally. We call the <code>foreach</code> method on the <code>args</code> array and pass in a function. Here we are passing a function literal that takes one parameter names <code>arg</code>. The body of the function is the single statement <code>println(arg)</code>. The syntax for a function literal is a list of named parameters, in parentheses, a right arrow, and then the body of the function. As you can see above the Scala interpreter infers the type of <code>arg</code> as <code>String</code>, since <code>String</code> is the element type of the array on which we called the foreach.<br>But if you would like be verbose we can explicitly type annotate the <code>arg</code> parameter as a <code>String</code>. And remember to add the parentheses when you explicitly type the parameter.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">args.foreach((arg: <span class="type">String</span>) =&gt; println(arg))</div></pre></td></tr></table></figure></p>
<p>If you would like to be concise and not explicit, you can use a shorthand form called as partially applied function. If a function literal consists of one statement that takes a single argument, you need not explicitly name and specify the argument.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">args.foreach(println)</div></pre></td></tr></table></figure></p>
<p>Ok but now you may think, what about the very famous imperative style for loops that we use in Java or C++. In an effort to guide Scala programmers in a functional direction, only a functional relative of the imperative for(called as for expression) is available in Scala.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(arg &lt;- args)</div><div class="line">    println(arg)</div></pre></td></tr></table></figure></p>
<p>The <code>arg</code> is a val and not a var here. Although <code>arg</code> may seem to be a var, it gets a new value on each iteration, it really is a val. <code>arg</code> can’t be reassigned inside the body of the for expression. A new <code>arg</code> val will be created and initialized to the element value during every iteration.</p>
<p>In Scala you can instantiate objects of a class using the <code>new</code> keyword. While instantiating a class you can also configure it with values and types. This is called as <strong>parameterization</strong>.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bigInteger = <span class="keyword">new</span> java.math.<span class="type">BigInteger</span>(<span class="string">"99637"</span>)</div></pre></td></tr></table></figure></p>
<p>The above code instantiates a new <code>java.math.BigInteger</code> and parameterizes it with the value “99637”. In the above case the instantiation process required only a value, but in some cases while instantiating you will have to provide the type also. You parameterize an instance with types by specifying one or more types in square brackets.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> messages = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">4</span>)</div><div class="line">messages(<span class="number">0</span>) = <span class="string">"Hello"</span></div><div class="line">messages(<span class="number">1</span>) = <span class="string">" world"</span></div><div class="line">messages(<span class="number">2</span>) = <span class="string">" from"</span></div><div class="line">messages(<span class="number">3</span>) = <span class="string">" Raj Abishek!\n"</span></div><div class="line"><span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">3</span>)</div><div class="line">  print(messages(i))</div></pre></td></tr></table></figure></p>
<p>As you can see above when we parameterize an instance with both a type and a value, the type comes first in its square brackets, followed by the value in parentheses. The type parameterization portion(the type names in square brackets) forms part of the type of the instance, the <code>messages</code> val created above is of type <code>Array[String]</code>. The type of <code>messages</code> is <code>Array[String]</code>, not <code>Array[String](4)</code>.</p>
<p>When you define a variable with val, the variable can’t be reassigned, but the object to which it refers could potentially still be changed. The below code is perfectly valid. The messages variable cannot be reassigned to a different array, it will always point to the same <code>Array[String]</code> instance with which it was initialized, but we can change the elements of that <code>Array[String]</code> over time, so the array itself is mutable.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">messages(<span class="number">0</span>) = <span class="string">"Bye"</span></div><div class="line">messages(<span class="number">1</span>) = <span class="string">" change"</span></div><div class="line">messages(<span class="number">2</span>) = <span class="string">" into"</span></div><div class="line">messages(<span class="number">3</span>) = <span class="string">" new text!\n"</span></div></pre></td></tr></table></figure></p>
<p>In Scala if a method takes only one parameter, you can call it without a dot or parentheses. This wouldn’t have been very evident, but when we wrote the for expression to loop through the array the code 0 to 3 is transformed into the method call (0).to(3).<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">3</span>)</div><div class="line">  print(messages(i))</div></pre></td></tr></table></figure></p>
<p>Its important to note here that this syntax will only works if you explicitly specify the receiver of the method call. You cannot write <code>println 10</code>, but we can write <code>Console println 10</code>.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/Programming-in-go/" class="prev">PREV</a><a href="/2016/Groovy-Essentials/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://rajabishek.com">Raj Abishek</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-93252193-1",'auto');ga('send','pageview');</script></body></html>