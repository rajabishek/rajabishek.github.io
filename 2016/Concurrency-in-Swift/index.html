<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script src="https://use.typekit.net/xbr6agj.js"></script><script>try{Typekit.load({ async: true });}catch(e){}</script><script>window['_fs_debug'] = false;
window['_fs_host'] = 'fullstory.com';
window['_fs_org'] = '6WVGW';
window['_fs_namespace'] = 'FS';
(function(m,n,e,t,l,o,g,y){
if (e in m) {if(m.console && m.console.log) { m.console.log('FullStory namespace conflict. Please set window["_fs_namespace"].');} return;}
g=m[e]=function(a,b){g.q?g.q.push([a,b]):g._api(a,b);};g.q=[];
o=n.createElement(t);o.async=1;o.src='https://'+_fs_host+'/s/fs.js';
y=n.getElementsByTagName(t)[0];y.parentNode.insertBefore(o,y);
g.identify=function(i,v){g(l,{uid:i});if(v)g(l,v)};g.setUserVars=function(v){g(l,v)};
g.identifyAccount=function(i,v){o='account';v=v||{};v.acctId=i;g(o,v)};
g.clearUserCookie=function(c,d,i){if(!c || document.cookie.match('fs_uid=[`;`]*`[`;`]*`[`;`]*`')){
d=n.domain;while(1){n.cookie='fs_uid=;domain='+d+
';path=/;expires='+new Date(0).toUTCString();i=d.indexOf('.');if(i<0)break;d=d.slice(i+1)}}};
})(window,document,window['_fs_namespace'],'script','user');
</script><title> Concurrency in Swift · Raj Abishek</title><meta name="description" content="Concurrency in Swift - Raj Abishek"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/logo.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">Blog</a></li><li class="nav-list-item"><a href="https://dribbble.com/rajabishek" target="_blank" class="nav-list-link">Dribbble</a></li><li class="nav-list-item"><a href="https://in.linkedin.com/in/rajabishek" target="_blank" class="nav-list-link">LinkedIn</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">Rss</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Concurrency in Swift</h1><div class="post-info">May 6, 2016</div><div class="post-content"><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This is an important concept that no developer can skip. It is a powerful feature that lets developers write efficient, fast, and responsive applications. With great power comes great responsibility. But once you understand the inner workings and dive a little deeper it becomes very easy to implement.</p>
<p>In iOS we have multiple APIs that can be used to achieve concurrency. One is NSOperation &amp; its associated classes and the other one is Grand Central Dispatch (GCD).</p>
<a id="more"></a>
<h2 id="Where-is-concurrency-used"><a href="#Where-is-concurrency-used" class="headerlink" title="Where is concurrency used ?"></a>Where is concurrency used ?</h2><p>Have you noticed that whenever we do some kind of a heavy tasks ( like database calls, fetching data from network, drawing graphics on screen) the UI is no longer responsive. The reason is that we are executing these heavy tasks on the main queue. iOS internally uses this main queue to respond to UI events. Therefore till out heavy task in completed iOS is not able to respond to user’s actions.</p>
<p>This is where concurrency comes in handy. We can perform all the heavy tasks concurrently. </p>
<h2 id="Concurrency-Parallelism"><a href="#Concurrency-Parallelism" class="headerlink" title="Concurrency != Parallelism"></a>Concurrency != Parallelism</h2><p>Now concurrency doesn’t mean parallelism. Both may look similar but they are different concepts to understand.<br>If you want to delve more deeply into this subject, check out this excellent <a href="http://vimeo.com/49718712" target="_blank" rel="external">talk by Rob Pike</a>.</p>
<p>Concurrency is when two or more tasks can start, run, and complete in overlapping time periods. It doesn’t necessarily mean they’ll ever both be running at the same instant. For example when multitasking on a single-core machine, the tasks do not literally run at the same time, they appear to run at the same time because time is sliced. For some amount of time one task runs and then another tasks runs for some time. It only looks as though the tasks are running in parallel, but actually they are not. Therefore parallelism comes into picture only when we have a multi core processor. But however the code is still concurrent (it has the ability to run in parallel if the hardware can allow).</p>
<p>Parallelism is when tasks literally run at the same time, Eg. on a multi core processor. Only if the code in concurrent, parallelism can be achieved. If the code does not allow parts of the program to run at the same time (no concurrency) then parallelism cannot be achieved.</p>
<h2 id="GCD-Grand-Central-Dispatch"><a href="#GCD-Grand-Central-Dispatch" class="headerlink" title="GCD (Grand Central Dispatch)"></a>GCD (Grand Central Dispatch)</h2><p>GCD is the most commonly used API to manage concurrent code and execute operations asynchronously. GCD is the marketing name for libdispatch, Apple’s library that provides support for concurrent code execution on multi core hardware on iOS and OS X.</p>
<p>GCD provides dispatch queues to handle submitted tasks.</p>
<h2 id="Dispatch-Queues"><a href="#Dispatch-Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>These queues manage the tasks you provide to GCD and execute those tasks in FIFO order. There are two varieties of dispatch queues one is serial and the other is concurrent. Any task that is added to any one of the queues is executed in separate threads than the thread in which they were created on. </p>
<p>Therefore whenever you want to perform some kind of computationally heavy task you create warp a block of code in a closure ( a task) and submit it to dispatch queues in the main thread. But all these tasks (closures) will run in separate threads instead of the main thread.</p>
<h2 id="Serial-Queues"><a href="#Serial-Queues" class="headerlink" title="Serial Queues"></a>Serial Queues</h2><p>This type of a queue can execute only one task at a time. The tasks will be executed in the order in which they were added to the queue. If 3 tasks were added to the serial queue then task 2 will wait for task 1 to complete and before its starts its execution. Similarly task 3 will wait for task 2 to complete before it starts. </p>
<p>A task in a serial queue will wait only for the preceding task in the same queue. It will not wait or depend on any other task that is present in a different queue. Therefore we can still execute tasks concurrently if we create multiple serial queues.<br>If lets say we create 3 serial queues and load them with tasks, then each queue executes only one task at a time, but we can have 3 tasks that are executing simultaneously one from each serial queue.</p>
<p>If we are having multiple tasks that share the same piece of data, executing them simultaneously will result in weird errors.This is called as race condition. Serial queues can help us solve this problem. By adding such tasks to a serial queue it is ensured that the tasks are executed sequentially only one at a time.</p>
<p>Some benefits of using a serial queue are:</p>
<ul>
<li>Sequential execution one at a time to avoid race condition of tasks accessing a shared resource</li>
<li>Tasks are executed in the same order as they are added in the queue</li>
<li>Multiple serial queues can be created</li>
</ul>
<h2 id="Concurrent-Queues"><a href="#Concurrent-Queues" class="headerlink" title="Concurrent Queues"></a>Concurrent Queues</h2><p>Current queues allows you to execute multiple tasks concurrently. The tasks that are added to the queue become ready for execution in the same order in which they are added. Unlike serial queues a task need to wait for the previous task to complete its execution before it starts. </p>
<p>Concurrent queues guarantee that tasks start in same order but you will not know the order of completion, execution time or the number of tasks being executed at a given point.</p>
<p>Lets say 3 tasks are added to the concurrent queue. Now task 1 becomes ready and its starts executing. Lets say that task 1 is a very heavy task and takes a very long time to complete. While task 1 is still running task 2 can start, after task 2 starts task 3 will start. Now before task 1 completes task 2 and task 3 can complete executing. Therefore only the order in which the tasks start executing is guaranteed and not anything else.</p>
<p>Some benefits of using a concurrent queue are:</p>
<ul>
<li>Tasks start executing in the same order as they are added in the queue</li>
<li>Multiple concurrent queues can be created</li>
<li>Apple provides four concurrent queues called as global dispatch queues</li>
<li>Tasks need not wait for the previous task to complete its execution before it starts executing</li>
</ul>
<h2 id="Dispatch-queues-in-action"><a href="#Dispatch-queues-in-action" class="headerlink" title="Dispatch queues in action"></a>Dispatch queues in action</h2><p>Now that we have seen both the type of queues. Its time to see on how we can put then to use. By default Apple provides 1 serial queue and 4 concurrent queues. The single serial queue is the main queue that executes the tasks on the applications main thread. It should be used to update the application’s UI and all tasks that make a change in the user interface. Since its a serial queue only one task can be execute at a time.</p>
<p>Besides the main queue, we have 4 concurrent queues, which are called the global dispatch queues. Each one of this queue has a different priority assigned to it. Before we use any one of them we should get a reference using the <code>dispatch_get_global_queue</code> function. The first parameter is priority and the second parameter is 0. The priority can be any one of the following.</p>
<ul>
<li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_LOW</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code></li>
</ul>
<p>The list is in the descending order of priority. Once we add tasks to any one of these 4 queues, lets say 2 tasks are ready for execution one from queue with <code>DISPATCH_QUEUE_PRIORITY_HIGH</code> priority and other from queue with <code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code> priority. The task from the queue with higher priority will be given preference first.</p>
<p>These constants were a part of Objective-C. In Swift we have the Quality of Service (QoS) class. The QoS classes are meant to express the intent of the submitted task so that GCD can determine how to best prioritize it.</p>
<ul>
<li><code>QOS_CLASS_USER_INTERACTIVE</code>: The user interactive class represents tasks that need to be done immediately in order to provide a nice user experience. Use it for UI updates, event handling and small workloads that require low latency. The total amount of work done in this class during the execution of your application should be small.</li>
<li><code>QOS_CLASS_USER_INITIATED</code>: The user initiated class represents tasks that are initiated from the UI and can be performed asynchronously. It should be used when the user is waiting for immediate results, and for tasks required to continue user interaction.</li>
<li><p><code>QOS_CLASS_UTILITY</code>: The utility class represents long-running tasks, typically with a user-visible progress indicator. Use it for computations, I/O, networking, continuous data feeds and similar tasks. This class is designed to be energy efficient.</p>
</li>
<li><p><code>QOS_CLASS_BACKGROUND</code>: The background class represents tasks that the user is not directly aware of. Use it for pre fetching, maintenance, and other tasks that don’t require user interaction and aren’t time-sensitive.</p>
</li>
</ul>
<p>Instead of using the constants we can use the quality of service class. We get the priority value from this class using the static value attribute of the class. </p>
<p>So you can decide the queue you use based on the priority of the task. Please also note that these queues are being used by Apple’s APIs so your tasks are not the only tasks in these queues.</p>
<p>We can create any number of serial queues and concurrent queues as we require. It is highly recommended that in case of concurrent queues we use any one of the default 4 queues available, instead of creating a new one.</p>
<h2 id="Lets-get-our-hands-dirty"><a href="#Lets-get-our-hands-dirty" class="headerlink" title="Lets get our hands dirty"></a>Lets get our hands dirty</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Get a reference to the main queue</span></div><div class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue()</div><div class="line"></div><div class="line"><span class="comment">//Get a reference to a global dispatch queue</span></div><div class="line"><span class="comment">//First parameter is the priority and second is always 0</span></div><div class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_UTILITY</span>.value), <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment">//Creating our own serial queue</span></div><div class="line"><span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.app.serialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</div><div class="line"></div><div class="line"><span class="comment">//Creating our own concurrent queue</span></div><div class="line"><span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.app.concurrentQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//Adding a task to the queue</span></div><div class="line">dispatch_async(queue, &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">	<span class="comment">//You're task is written here</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></div></article></div></section><footer><div class="paginator"><a href="/2016/Getting-started-with-Nginx-configuration/" class="prev">PREV</a><a href="/2016/SOLID-Principles/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://rajabishek.com">Raj Abishek</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-93252193-1",'auto');ga('send','pageview');</script></body></html>