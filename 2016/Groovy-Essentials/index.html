<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script src="https://use.typekit.net/xbr6agj.js"></script><script>try{Typekit.load({ async: true });}catch(e){}</script><script>window['_fs_debug'] = false;
window['_fs_host'] = 'fullstory.com';
window['_fs_org'] = '6WVGW';
window['_fs_namespace'] = 'FS';
(function(m,n,e,t,l,o,g,y){
if (e in m) {if(m.console && m.console.log) { m.console.log('FullStory namespace conflict. Please set window["_fs_namespace"].');} return;}
g=m[e]=function(a,b){g.q?g.q.push([a,b]):g._api(a,b);};g.q=[];
o=n.createElement(t);o.async=1;o.src='https://'+_fs_host+'/s/fs.js';
y=n.getElementsByTagName(t)[0];y.parentNode.insertBefore(o,y);
g.identify=function(i,v){g(l,{uid:i});if(v)g(l,v)};g.setUserVars=function(v){g(l,v)};
g.identifyAccount=function(i,v){o='account';v=v||{};v.acctId=i;g(o,v)};
g.clearUserCookie=function(c,d,i){if(!c || document.cookie.match('fs_uid=[`;`]*`[`;`]*`[`;`]*`')){
d=n.domain;while(1){n.cookie='fs_uid=;domain='+d+
';path=/;expires='+new Date(0).toUTCString();i=d.indexOf('.');if(i<0)break;d=d.slice(i+1)}}};
})(window,document,window['_fs_namespace'],'script','user');
</script><title> Groovy Essentials · Raj Abishek</title><meta name="description" content="Groovy Essentials - Raj Abishek"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/logo.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">Blog</a></li><li class="nav-list-item"><a href="https://dribbble.com/rajabishek" target="_blank" class="nav-list-link">Dribbble</a></li><li class="nav-list-item"><a href="https://in.linkedin.com/in/rajabishek" target="_blank" class="nav-list-link">LinkedIn</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">Rss</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Groovy Essentials</h1><div class="post-info">Sep 18, 2016</div><div class="post-content"><h2 id="Why-learn-groovy"><a href="#Why-learn-groovy" class="headerlink" title="Why learn groovy ?"></a>Why learn groovy ?</h2><p>Anyone who is comfortable working in Java can pickup groovy very easily. It is a general-purpose programming language which compiles down to Java byte code. It is an object oriented programming language with functional capabilities.</p>
<p>Even if you don’t want to write applications with groovy leaning this technology can be helpful while working with gradle. Gradle is a modern open source build tool for continuous delivery for applications written in Java, C++, Native android, Python, Hadoop and many more. </p>
<a id="more"></a>
<p>The Gradle build files consist largely of a Domain Specific Language, written in Groovy, for builds. In addition to the DSL, any legal Groovy code can be added to the build. In 2013 Google also chose gradle as the go to build tool for android application with internal support in Android Studio. There is a plugin for gradle that allows us to configure android applications. There are various build types available, we could build a release build or a debug build. We could setup an automatic signing configuration, so that we can digitally sign the output apks in preparation for uploading them to the google play store. We can also define additional build types if we want. We will also look at the concept of flavors.</p>
<p>A flavor allows you to essentially build the same app in multiple different ways with slight changes to the look and feel or even changes to the application itself. A combination of a flavour and a build type is known as a variant. We will also look at using our own android library projects as part of a larger android application, so that we can split functionality into reusable components that can be part of other applications as well.</p>
<h2 id="A-bit-of-history"><a href="#A-bit-of-history" class="headerlink" title="A bit of history"></a>A bit of history</h2><p>When android applications were first created was first created there was no real separate build toll available. At that time build for android was an IDE build, i.e we would build an application in an IDE rather than having some separate execution process for building the application itself. Previously there was a plugin for eclipse called ADT(Android developer tools). Back then once you download the ADT plugin and add it to the eclipse IDE, that would take care about building the project. But this was something that the Java community had moved away from for the last 10-15 years, because doing this way would be difficult to reproduce outside an IDE and for example trying to build something on a CI server becomes something that is very difficult. One of the issues was that we could not build different types of the same application at the same time.</p>
<p>So in 2013 Android decided to switch to a real build tool called as gradle and they replaced the IDE to Android Studio which a free version of IntellijIDEA that understands gradle better. In the background Android studio is running the gradle tasks. You can even think the android studio as a UI wrapper around the gradle build tool. The android plugin for gradle runs independent of Android studio, so you could build your app from the command line also or on machines where android studio is not installed (such as CI servers). With gradle we can handle build variants, dependencies, manage manifest entries, deal with signing configurations, run the proguard tool and perform testing.</p>
<h2 id="Groovy-Classes-amp-Objects"><a href="#Groovy-Classes-amp-Objects" class="headerlink" title="Groovy - Classes &amp; Objects"></a>Groovy - Classes &amp; Objects</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></div><div class="line">	String first</div><div class="line">	String last</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person person = <span class="keyword">new</span> Person()</div><div class="line">person.setFirst(<span class="string">'Raj'</span>)</div><div class="line">person.last = <span class="string">'Abishek'</span></div><div class="line">println <span class="string">"$&#123;person.getFirst()&#125; $&#123;p.last&#125;"</span></div></pre></td></tr></table></figure>
<p>This is a sample groovy code show above. In groovy fields are private by default(in Java they are package-private by default). Also in groovy methods are public by default and class itself is public by default. Now if you want a public field or a private method you have to use those access modifiers while defining them. In groovy if you don’t provide an access modifier for the fields then it automatically generates getters and setters for them. Ok Raj, you told me that the fields are private by default then how are you able to access the last field shown above. The thing is that groovy automatically converts to the corresponding getter or setter method whenever you are trying to access the fields directly. So actually the line person.last = ‘Abishek’ is internally interpreted as person.setLast(‘Abishek’) and similarly the p.last is interpreted as p.getLast(). Infact if you had defined a setLast method on the class manually like this<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> setLast(String last) &#123;</div><div class="line">	println <span class="string">'inside set last'</span></div><div class="line">	<span class="keyword">this</span>.last = last</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>then while executing the statement person.last = ‘Abishek’, the string inside set last will be printed. So when it looks like you are doing property access you are indirectly using the getters and setters. Infact even if you don’t have a property called test in the class and you try to access it via an instance the groovy will internally call the instance.getTest method. So it is important to note here that you could get away with just having the the getters and setters and not the property itself and accessing the property will invoke the getters and setters.</p>
<p>In Java if you don’t get a constructor you just get one default constructor, but in groovy you get 2 default costrcutor one is like how you have in Java and another one is a default memberwise initialization constructor(Like the default constructor for structures in Swift programming language). But the beauty here is that unlike the swift memberwise constructor you need not provide values for all the fields also. You can just provide the values for those fields that you want and for others groovy will assign default values null for references, 0 for numerics and false for booleans just like Java. Therefore for the person class defined above you could create an instance using <code>Person person = new Person(first: &#39;Raj&#39;, last: &#39;Abishek&#39;)</code>. And as I said previously we can also just provide the values for the fields that we want and for others groovy will give a default value <code>Person person = new Person(first: &#39;Raj&#39;)</code> will create a person object with first as ‘Raj’ and the last field will be given a default value of null.But it is important to note here that when you are using this member wise constructor the values for the property are assigned using the setter methods for the properties. Therefore we would get the inside set last string output. Therefore the member wise initialization constructor uses the setter methods to assign values for the properties.</p>
<p>You could also have a toString method on the class that will be automatically called when you pass an instance to the println function.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String toString() &#123; <span class="string">"$&#123;first&#125; $&#123;last&#125;"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>In groovy if you observer you don’t even need the return statement because it will automatically return the last evaluated expression in the block and not only that it will look at the return type of the method and try to convert the last evaluated expression to the return type if the types are not matching.</p>
<p>Now lets take a look at AST transformation i.e Abstract syntax tree transformation. To look at this concept first we need to look at import statements. Its important to understand here is that by default groovy imports a couple of packages, like <code>java.lang.*</code>, <code>java.util.*</code>, <code>java.io.*</code>, <code>java.net.*</code>, <code>groovy.lang.*</code>, <code>groovy.util.*</code> and other important packages. Now AST transformation allows groovy developers to typehint annotations at the top of a class and groovy will automatically provide that functionality.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groovy.transform.*</div><div class="line"></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></div><div class="line">	String first</div><div class="line">	String last</div><div class="line"></div><div class="line">	String toString() &#123; <span class="string">"$&#123;first&#125; $&#123;last&#125;"</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The @ToString annotation will automatically provide a toString method for a class. In our cause since we have manually provided a method groovy will not overwrite it. Groovy will only provide a method if its already not there. But if remove this toString method from the class then groovy will provide a toString method.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groovy.transform.*</div><div class="line"></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></div><div class="line">	String first</div><div class="line">	String last</div><div class="line">&#125;</div><div class="line">Person person = <span class="keyword">new</span> Person(<span class="string">first:</span> <span class="string">'Raj'</span>, <span class="string">last:</span> <span class="string">'Abishek'</span>)</div><div class="line">println person</div></pre></td></tr></table></figure></p>
<p>Now we would get the output as <code>Person(Raj, Abishek)</code>, because this is the way how groovy provides the toString method internally. We can actually typehint multiple annotations to provide multiple functionalities. @EqualsAndHashCode method will generate an equals method and a hashCode method on the Person class according to the normal condition layed out in the Effective Java book. When you actually compare two instances in groovy using the == operator it is operator overloading in action internally groovy calls the equals method on the first instance and passes the 2nd instance as a parameter. Therefore by typehinting the <code>@EqualsAndHashCode</code> annotation above the Person class we can actually use the == operator for comparing two instances of the person class to check whether the values are equal.(Unlike java that compares the references).<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groovy.transform.*</div><div class="line"></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="meta">@EqualsAndHashCode</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></div><div class="line">	String first</div><div class="line">	String last</div><div class="line">&#125;</div><div class="line">Person person1 = <span class="keyword">new</span> Person(<span class="string">first:</span> <span class="string">'Raj'</span>, <span class="string">last:</span> <span class="string">'Abishek'</span>)</div><div class="line">Person person2 = <span class="keyword">new</span> Person(<span class="string">first:</span> <span class="string">'Raj'</span>, <span class="string">last:</span> <span class="string">'Abishek'</span>)</div><div class="line">println person1 == person2</div></pre></td></tr></table></figure></p>
<p>The output of the above code is true because the values are being compared. The == operator is actually calling the equals method on the <code>Person</code> class. There is another transformation called as @TupleConstructor that generates a new constructor that allows us to specify the values for the fields in the same order without providing the parameters names while calling the constructor.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groovy.transform.*</div><div class="line"></div><div class="line"><span class="meta">@TupleConstructor</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></div><div class="line">	String first</div><div class="line">	String last</div><div class="line">&#125;</div><div class="line">Person person1 = <span class="keyword">new</span> Person(<span class="string">'Raj'</span>,<span class="string">'Abishek'</span>)</div></pre></td></tr></table></figure></p>
<p>As you can see in the above code, type hinting <code>@TupleConstructor</code> generates a new constructor for providing the values for the fields in the same order in which they were defined without the need for naming the parameters. The combination of the @ToString, @EqualsAndHashCode and @TupleConstructor is so popular that there is another transformation called as @Canonical that is functionally equivalents to writing these 3 transformations together.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groovy.transform.*</div><div class="line"></div><div class="line"><span class="meta">@ToString</span></div><div class="line"><span class="meta">@EqualsAndHashCode</span></div><div class="line"><span class="meta">@TupleConstructor</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></div><div class="line">	String first</div><div class="line">	String last</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The above code is the same as the below code.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groovy.transform.*</div><div class="line"></div><div class="line"><span class="meta">@Canonical</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></div><div class="line">	String first</div><div class="line">	String last</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Groovy-Closures-amp-Collections"><a href="#Groovy-Closures-amp-Collections" class="headerlink" title="Groovy - Closures &amp; Collections"></a>Groovy - Closures &amp; Collections</h2><p>Lets make a collection of person references.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groovy.transform.*</div><div class="line"></div><div class="line"><span class="meta">@Canonical</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></div><div class="line">	String first</div><div class="line">	String last</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">def</span> people = [</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Raj'</span>,<span class="string">'Abishek'</span>),</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Sailesh'</span>,<span class="string">'Dev'</span>),</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Dev'</span>,<span class="string">'Prakash'</span>),</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Kani'</span>,<span class="string">'Amuthu'</span>)</div><div class="line">]</div><div class="line"></div><div class="line">println people.<span class="keyword">class</span>.name</div></pre></td></tr></table></figure></p>
<p>As you know by now when accessing properties, internally the methods are called. There it is functionally equivalent to calling people.getClass().getName() which will print <code>java.util.ArrayList</code>. So the people above is a collection, its an array list of person objects. But what if we wanted a linkedlist instead, you could use <code>LinkedList</code> instead of the def keyword above or you can do.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> people = [</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Raj'</span>,<span class="string">'Abishek'</span>),</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Sailesh'</span>,<span class="string">'Dev'</span>),</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Dev'</span>,<span class="string">'Prakash'</span>),</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Kani'</span>,<span class="string">'Amuthu'</span>)</div><div class="line">] <span class="keyword">as</span> LinkedList</div></pre></td></tr></table></figure></p>
<p>The people variable above is a instance of <code>java.util.LinkedList</code> now. If used as <code>Set</code> then we would get an instance of <code>LinkedHashSet</code>, which will make sure that we don’t have any duplicates, thank to the @Canonical transformation for providing the equals and hashCode method using which the set collection is able to maintain a list of unique elements alone. We could also do <code>as TreeSet</code> which will give us a sorted set but we haven’t implemented the comparable interface that allows the tree set to decide on how its going to sort. In groovy we needn’t manually implement the comparable interface as there is an AST transformation for that too called as @Sortable.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groovy.transform.*</div><div class="line"></div><div class="line"><span class="meta">@Canonical</span></div><div class="line"><span class="meta">@Sortable</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></div><div class="line">	String first</div><div class="line">	String last</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">def</span> people = [</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Raj'</span>,<span class="string">'Abishek'</span>), <span class="comment">//#1</span></div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Raj'</span>,<span class="string">'Abishek'</span>), <span class="comment">//#2</span></div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Raj'</span>,<span class="string">'Dev'</span>),</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Sailesh'</span>,<span class="string">'Dev'</span>),</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Dev'</span>,<span class="string">'Prakash'</span>),</div><div class="line">	<span class="keyword">new</span> Person(<span class="string">'Kani'</span>,<span class="string">'Amuthu'</span>)</div><div class="line">] <span class="keyword">as</span> TreeSet</div><div class="line"></div><div class="line">println people</div></pre></td></tr></table></figure></p>
<p>First of all since its a set we won’t have any duplicates so only one of #1 or #2 will be there. Secondly its will make sure that the list is sorted. It will sort the instances based on the first name and then the last name alphabetically.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</div><div class="line">println nums</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i) &#123; println nums[i] &#125;</div></pre></td></tr></table></figure></p>
<p>As you can see above the normal for loop with the subscript sytax works fine even though the collection is an array list because internally when you use the subscript nums[i] groovy calls the <code>get</code> method on the array list collection. Another option to loop through the list is we can use java’s foreach operator.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="string">num :</span> nums) &#123; println num &#125;</div></pre></td></tr></table></figure></p>
<p>We also have something called as a for in loop in groovy where we can do the following. This is similar to the foreach lopp in java but we need not typehint the datatype of the array element in the index.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">for</span>(num <span class="keyword">in</span> nums) &#123; println num &#125;</div></pre></td></tr></table></figure></p>
<p>The another interesting way in which we would do this in groovy would be with the help of clousures. The curly brace is like the curly brace inside a method or a function. It takes one argument by default and it is called as it.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</div><div class="line">nums.each &#123; println it &#125;</div><div class="line">nums.each &#123; n -&gt; println n &#125;</div></pre></td></tr></table></figure></p>
<p>As you can see above if we want to give a different name for the parameter then we can give a different name followed by right arrow. As you can see above doing this, only <code>n</code> is available and <code>it</code> is not available. The each method also returns the collection itself. One of the trends that has become very popular in computer science is the idea of moving towards functional programming. The benefits of functional programming are many but it especially works with small easily composable functions that can be combines with immutable classes inorder to make something that is easy to parallelize and optimize. Its is a very nice system that can minimize a lot of side effects. Groovy is an object oriented language with the concept of closures it can actually do certain functional things. We also have a collect method on the collection that returns a new collection based on the closure that we provide. It applies the closure to each element and returns a new collection based on that. This is similar to the map method present in other programming languages.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</div><div class="line">nums.collect &#123; it * <span class="number">2</span> &#125;</div></pre></td></tr></table></figure></p>
<p>There is another method called findAll that finds all elements in the collection that satisfies the closure. This is similar to the filter method that is present in other programming languages. The sum method will calculate the sum of all the elements in the collection.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</div><div class="line">nums.collect &#123; it * <span class="number">2</span> &#125;</div><div class="line">	.findAll &#123; it%<span class="number">3</span> == <span class="number">0</span> &#125;</div><div class="line">	.sum()</div></pre></td></tr></table></figure></p>
<p>The output of the above code is 24. First we find the twice of every number and then filter the elements that is divisible by 3 and they find the sum of those elements. We have seen about linear collections so far, now lets take a look at maps or dictionaries.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> map = [<span class="string">k1:</span><span class="number">1</span>, <span class="string">k2:</span><span class="number">2</span>, <span class="string">k3:</span><span class="number">3</span>]</div><div class="line">println map.getClass().name</div></pre></td></tr></table></figure></p>
<p>The output we get is <code>java.util.LinkedHashMap</code>. As you see above we had to use the getClass() method and not the class property because, in a map the . operator is overloaded for putting and getting values from the map. Therefore if we would have used the class property then the map would have looked for a key called class which does not exist and would have returned null, it woudn’t have actually called the getClass method internally. We can put values into the map using the . operator or using the subscript syntax as shown below.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> map = [<span class="string">k1:</span><span class="number">1</span>, <span class="string">k2:</span><span class="number">2</span>, <span class="string">k3:</span><span class="number">3</span>]</div><div class="line">map.k4 = <span class="number">1</span></div><div class="line">map[<span class="string">'k5'</span>] = <span class="number">2</span></div><div class="line">println map</div></pre></td></tr></table></figure></p>
<p>To iterate over the map we can use the each function.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> map = [<span class="string">k1:</span><span class="number">1</span>, <span class="string">k2:</span><span class="number">2</span>, <span class="string">k3:</span><span class="number">3</span>]</div><div class="line">map.each &#123; e -&gt; println <span class="string">"$&#123;e.key&#125; maps to $&#123;e.value&#125;"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>The e.key internally calls the e.getKey() and the e.value calls the e.getValue() method, normal property access calls the methods internally. The each methods also supports a two argument closure that will pass the key and the value to the closure.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> map = [<span class="string">k1:</span><span class="number">1</span>, <span class="string">k2:</span><span class="number">2</span>, <span class="string">k3:</span><span class="number">3</span>]</div><div class="line">map.each &#123; k,v -&gt; println <span class="string">"$k maps to $v"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>As you can see above during string interpolation we need not use the {} after the $ if we are just outputting the value and not accessing a property or method. If we use the collect method on the map it transforms it into a list by applying the closure to each element.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> map = [<span class="string">k1:</span><span class="number">1</span>, <span class="string">k2:</span><span class="number">2</span>, <span class="string">k3:</span><span class="number">3</span>]</div><div class="line">map.collect &#123; k,v -&gt; <span class="string">"$k=$v"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>The output is [k1=1, k2=2, k3=2]. The list also has a method called join that joins the elements of the list using the separator given.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> map = [<span class="string">k1:</span><span class="number">1</span>, <span class="string">k2:</span><span class="number">2</span>, <span class="string">k3:</span><span class="number">3</span>]</div><div class="line">map.collect &#123; k,v -&gt; <span class="string">"$k=$v"</span> &#125;.join(<span class="string">'&amp;'</span>)</div></pre></td></tr></table></figure></p>
<p>The output is k1=1&amp;k2=2&amp;k3=2. The collect methods transforms the map to a list and the join method on the list combines the elements using the &amp; separator.</p>
<h2 id="Accessing-a-RESTFUL-web-service"><a href="#Accessing-a-RESTFUL-web-service" class="headerlink" title="Accessing a RESTFUL web service"></a>Accessing a RESTFUL web service</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groovy.json.*</div><div class="line"></div><div class="line">String url = <span class="string">'http://api.icndb.com/jokes/random?'</span></div><div class="line"><span class="keyword">def</span> params = [<span class="string">limitTo:</span><span class="string">'[nerdy]'</span>, <span class="string">firstName:</span> <span class="string">'Raj'</span>, <span class="string">lastName:</span> <span class="string">'Abishek'</span>]</div><div class="line">String queryString = params.collect &#123; k,v -&gt; <span class="string">"$k=$v"</span> &#125;.join(<span class="string">'&amp;'</span>)</div><div class="line">String jsonTxt = <span class="string">"$url$queryString"</span>.toURL().text</div><div class="line"><span class="keyword">def</span> json = <span class="keyword">new</span> JsonSlupper().parseText(jsonTxt)</div><div class="line">println json.value.joke</div></pre></td></tr></table></figure>
<p>As you can see in the above example first we store the parameters for the request in the map. Then we convert in unto a query string and append it to the end of the url. Then groovy have a <code>toURL</code> method on string object to convert a string to a <code>java.net.URL</code> instance and then we access the text property to call the <code>getText</code> method on the url instance. This gives us the JSON result as a string which needs to be parsed. To parse the JSON string we create an instance of <code>JsonSlupper</code> class from the <code>groovy.json</code> package and then call the <code>parseText</code> method to convert the JSON string to a map.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/Functional-Thinking-Scala/" class="prev">PREV</a><a href="/2016/Snackbar-Android-Material-Design/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://rajabishek.com">Raj Abishek</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-93252193-1",'auto');ga('send','pageview');</script></body></html>